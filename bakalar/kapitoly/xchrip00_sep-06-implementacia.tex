\chapter{Implementácia}
Implementáciou sa skladá z nasledujúcich súborov:
\begin{itemize}
	\item \textbf{\texttt{test\_generator.py}} -- obsahuje testy generátora,
	\item \textbf{\texttt{test\_assimilator.py}} -- obsahuje testy asimilátora,
	\item \textbf{\texttt{test\_runner.py}} -- obsahuje testy pre runner,
	\item \textbf{\texttt{test\_api.py}} -- obsahuje testy pre API,
	\item \textbf{\texttt{hashcat\_mock.py}} -- náhrada hashcatu,
	\item \textbf{\texttt{hashcat\_parsers.py}} -- obsahuje parsery používané pri testoch runneru,
	\item \textbf{\texttt{api\_response\_models.py}} -- obsahuje funkcie, ktoré konvertujú údaje do formátu \texttt{json}, tak ako to robí API,
	\item \textbf{\texttt{config.py}} -- konfiguračný súbor obsahujúci informácie k databáze, cestám k súborom a iné,
	\item \textbf{\texttt{fc\_test\_library.py}} -- obsahuje funkcie, triedy a enum-y používané pri testovaní
	\item \textbf{\texttt{main.py}} -- postupne spúšťa všetky testovacie triedy
	\item \textbf{\texttt{database/}} -- balíček s súbormi pracujucími s databázou
		\begin{itemize}
			\item \textbf{\texttt{models.py}} -- definície tabuliek databázy
			\item \textbf{\texttt{service.py}} -- funkcie pristupujúce do databázy
		\end{itemize}
\end{itemize}
Súbory začínajúce \texttt{test\_} obsahujú testy a pomocné funkcie k testovaniu jednotlivých modulov.
Testovacie funkcie majú prefix \texttt{test\_}.
Je možné ich spustiť typicky: \texttt{python3 test\_*.py}, alebo vybrať pomocou unittest frameworku vybrať konkrétny súbor, triedu, alebo test:
\begin{verbatim}
	python3 -m unittest test_runner
	python3 -m unittest test_runner.TestRunner
	python3 -m unittest test_runner.TestRunner.test_benchmark_ok
\end{verbatim}


Testy využívajú vzor fixtures~\ref{fixtures}, konkrétne funkcie z frameworku unittest:
\begin{itemize}
	\item \texttt{setUpClass} je volaná pred spustením prvého testu a pripravuje systém na testovanie modulu.
		Typicky vypína všetky systémové moduly, okrem testovaného a pripravuje databázu: vymaže všetky záznamy z tabuliek, ktoré budú testované a pridá záznamy, ktoré sa nebudú meniť počas testovania celého modulu, napríklad pridanie balíčka pri testovaní asimilátora.
	\item \texttt{tearDownClass}  je volaná po skončení posledného testu a má za úlohu vrátiť SUT do stavu pred testovaním, takže opäť zapne ostatné moduly a vymaže záznamy, ktoré boli pridané počas testovanie.
	\item \texttt{setUp} je funkcie volaná pred každým testom, typicky nastavuje parametre Fitcracku, ktoré sa menia počas testu, alebo pridáva záznamy.
	\item \texttt{tearDown} je volaná po skončení každého testu a väčšinou má na starosti mazanie záznamov tabuliek, ktoré by mohli ovplyvniť nasledujúce testy.
\end{itemize}

Súbor \textbf{\texttt{fc\_test\_library.py}} obsahuje okrem iného aj funckie pre ovládanie Fitcracku a jeho modulov a tiež triedy:
\begin{itemize}
	\item \textbf{\texttt{FitcrackTLVConfig}}, ktorá reprezentuje TLv konfiguračný súbor posielaný klientovi. 
		Objekt tejto triedy je možné vytvoriť zadaním parametrov, alebo prečítať priamo zo súboru.
		Tento objekt je následne možné reprezentovať ako reťazec a zapísať do súboru.
		Trieda je používaná na generovanie a kontrolovanie konfiguračný súborov vytvorených generátorom.
	\item \textbf{\texttt{RunnerOutput}} reprezentuje výstupný súbor modulu runner. Objekt triedy môže obsahovať rôzne atribúty v závislosti na type úlohy z ktorej bol generovaný.
\end{itemize}

Nasledujúce kapitoly obsahujú niektoré implementačné detaily testov podľa serverových modulov.

\section{Implementácia testov pre serverový modul assimilátor}
\label{impl_asim}
Pri bližšom pohľade na CFG asimilátora~\ref{fig:cfg_asim} a na zoznam primárnych ciest~\ref{navrh_asim} sa každá cesta opakuje so zmeneným len posledným uzlom, kde uzol číslo \texttt{15} znamená, že asimilovaná úloha sa má zmazať a uzol číslo \texttt{16} nastavuje asimilovanej úlohe príznak \texttt{finished}.
Framework unittest ponúka pre tieto účely možnosť definovať si \texttt{subtest}\footnote{\url{https://docs.python.org/3.6/library/unittest.html\#distinguishing-test-iterations-using-subtests}}, ktorý slúži na spúštanie podobných testov.
Subtest-u je predaná meniaci sa argument a pri výpise je potom jasné pre ktoré hodnoty tohto argumnety test prešiel, alebo nie.
V našom prípade je parametrom príznak mazania dokončených úloh.

\subsection*{Príprava SUT a návrat SUT do stavu pred testovaním}
\begin{description}
	\item \textbf{\texttt{setUpClass}}: pred spustením testov je potrebné vymazať z databáze všetky záznamy, ktoré by mohli ovplyvniť testy, zastaviť všetky serverové moduly okrem asimilátora a pridať balíček, pre ktorý budú generované dokončené úlohy, keďže asimilátor má na starosti spracovať výsledky dokončených úloh.
	\item \textbf{\texttt{tearDownClass}}: po testoch je analogicky potrebné spustiť všetky serverové moduly, vymazať tabuľky, ktoré boli ovplyvnené testami a vymazať príznak mazanie dokončených úloh z databázy.
\end{description}

\subsection*{Štruktúra priečinkov}
Súčasťou dokončenej úlohy je výstupný súbor modulu runner, ktorý sa však nenachádza priamo v databáze, kedže Fitcrack podporuje hierarchickú štruktúru stiahnutých a odoslaných priečinkov\footnote{\url{https://boinc.berkeley.edu/trac/wiki/DirHierarchy}}.
V praxi to funguje tak, že na servery existujú zložky \texttt{downloads} a \texttt{uploads}.
Každá z týchto zložiek ďalej obsahuje množstvo priečinkov s 3 znakovými názvami pozostávajúcimi z písmen, alebo čísel, tieto názvy sa vypočítajú ako hashe názvov súborov, ktoré obsahujú.
Boinc poskytuje nástroj \texttt{dir\_hier\_path}, ktorý berie na vstup meno súboru a výstup je cesta k tomuto súboru.

Databáza potom obsahuje XML súbor s odkazmi súborov patriacich k danej úlohe. Boinc viem v tejto štruktúre vyhľadávať súbory len podľa názvu.

Pre potreby testovania je naopak potrebné umiestniť súbory do správnych priečinkov a vytvoriť XML súbor, ktorý je predaný cez databázu modulu asimilátor. \\

\subsection*{Čakanie na dokončenie asimilácie}
Čas testovania je najviac ovplyvnený tým, ako test zistí, že asimilátor dokončil úlohu.
Tým, že asimilátor je volaný z Boinc-u, tak nie je možné presne zistiť kedy dokončil úlohu.
Ponúkajú sa 3 riešenia:
\begin{itemize}
	\item Najjednoduchšie riešenie je počkať dopredu stanovený limit, no ten je veľmi ťažké určiť, keďže nie je známe ako často Boinc kontroluje obsah tabuliek a volá vstupnú funkciu asimilátora \texttt{assimilate\_handler()}.
		Takisto je ťažké určiť koľko bude trvať, kým sa do databáze zapíšu všetky záznamy.

	\item Ďalšia možnosť je počkať, kým asimilátor zapíše niečo do logovacieho súboru.
		Na začiatku testovania bol tento spôsob využívaný, ale testy trvali veĺmi dlho, v priemere okolo 9 sekúnd na test, pričom údaje boli v databáze zapísané už skôr.
		Predsalen súborový systém nie je navrhnutý nato zapísať zmeny v súbore čo najrýchlejšie.
		Spoliehať sa pri testovaní nato, že SUT zapíše niečo do logovacieho súboru tiež nie je veľmi dobré riešenie.

		\sloppy
	\item Nakoniec bolo implementované cyklické dotazovanie databázy na zmenu príznaku \texttt{assimilate\_state}, alebo na vymazanie konkrétnej úlohu, podľa toho, či je v danom teste nastavený príznak úlohy \texttt{delete\_finished}.
		Vďaka použitiu frameworku \texttt{SQL Alchemy}, ktorý sa sám stará o obnovovanie dát z databázy je toto riešenie jednoduché a funguje dobre.
\end{itemize}

\subsection*{Pokrytie primárnych ciest}
\begin{itemize}
	\item \texttt{test\_bench\_error}: $t_1 = \{[0, 1, 5, 14, 15], [0, 1, 5, 14, 16]\}$
	\item \texttt{test\_normal\_found}: $t_2 = \{[0, 6, 7, 8, 14, 15], [0, 6, 7, 8, 14, 16]\}$
	\item \texttt{test\_normal\_error}: $t_3 = \{[0, 6, 7, 13, 14, 15], [0, 6, 7, 13, 14, 16]\}$
	\item \texttt{test\_bench\_ok\_mask}: $t_4 = \{[0, 1, 2, 3, 4, 14, 15], [0, 1, 2, 3, 4, 14, 16]\}$
	\item \texttt{test\_normal\_not\_found\_small}: $t_5 = \{[0, 6, 7, 9, 10, 11, 14, 15], [0, 6, 7, 9, 10, 11, 14, 16]\}$
	\item \texttt{test\_normal\_not\_found}: $t_6 = \{[0, 6, 7, 9, 10, 11, 12, 14, 15], [0, 6, 7, 9, 10, 11, 12, 14, 16]\}$, ktorý sa sám stará o obnovovanie dát z databázy je toto riešenie jednoduché a funguje dobre.

	\item \texttt{test\_bench\_no\_file}: $t_7 = \{[0, 1, 14, 15], [0, 1, 14, 16]\}$
	\item \texttt{test\_bench\_ok}: $t_8 = \{[0, 1, 2, 4, 14, 15], [0, 1, 2, 4, 14, 16]\}$
\end{itemize}
Cesty $[0, 6, 14, 15]$ a $[0, 6, 14, 16]$ sú syntakticky nedosiahnuteľné, kedže typ úlohy nemôže byť iný ako \texttt{normal} alebo \texttt{benchmark}.
\begin{center}
$T_1 = {t_1, t_2, \ldots t_6}$ splňuje PPC. 
\end{center}

\bigskip
\noindent
Bližšie informácie o implementácii jednotlivých testovacích prípadov poskytujú zdrojové kódy.


\section{Implementácia testov pre serverový modul generátor}
\label{impl_gen}
Testovanie modulu generátor rozsiahle a implementované testy síce spĺňajú kritérium pokrytia všetkých uzlov pseudokódu~\ref{alg:generator}, ale pseudokód nespomína niektoré celkom závažné detaily imlementácie, ako rôzny typy úloh, výpočet veľkosti úlohy v závislosti na sile hosťa, delenie úlohy pri opätovnom pridelení nedokončenej úlohy a iné.

Je potrebné overovať správnosť konfiguračných súborov vo formáte XML, ako aj TLV konfiguračných slovníkov vytvorených generátorom pre runner. Pred spustením testov musí databáza obsahovať slovníky používané pri testovaní.

\subsection*{Čakanie na vygenerovanie úlohy}
Podobne ako pri asimilátore~\ref{impl_asim} boli 3 možnosti ako zistiť, že generátor skončil činnosť:
\begin{itemize}
	\item čakanie pevne stanovenú dobu,
	\item čakanie na zápis do logovacieho súboru, 
	\item alebo čakanie na zmenu v databáze.
\end{itemize}
Pre asimilátor bola najlepšia možnosť čakať na zmenu v databáze, kedže stačilo sledovať 2 typy zmien, no generátor vytvára a mení rôzne záznamy rôzne, preto nie je stále možné použiť túto možnosť.

Keďže generátor pracuje v nekonečnom cykle, tak do logovacieho súboru zapisuje niekoľko krát za sekundu, čo podstatne zrýchli testy, no očakávana zmena sa nemusela stať hneď vtom prvom cykle, ktorý bol monitorovaný, ale až v ďalších, čo skreslovalo výsledky testov.

Nakoniec bola použitá metóda čakania na zmenu v databáze všade tam, kde to bolo možné a inak sa čaká pevne stanovenú dobu aj napriek spomaleniu vykonávanie testov.
Implementácia obssahuje všetky 3 funkcie, hlavne pre rozširovanie testovacej sady, keďže pri module generátor nie je jasné, ktorú je najlepšieu používať.

\subsection*{Pokrytie primárnych ciest}
\begin{itemize}
	\item \texttt{test\_del\_fin\_host}: $t_1 = [0, 24]$
	\item \texttt{test\_del\_exh\_host}: $t_2 = [0, 24]$
	\item \texttt{test\_passed\_time}: $t_3 = [0, 1, 24]$
	\item \texttt{test\_package\_set\_start\_time}: $t_4 = [0, 2, 3, 4, 5, 7, 8, 11, 24]$
	\item \texttt{test\_make\_benchmark}: $t_5 = [0, 2, 8, 9, 10, 11, 24]$
	\item \texttt{test\_add\_host\_to\_package}: $t_6 = [0, 2, 3, 5, 7, 24]$
	\item \texttt{test\_enough\_jobs}: $t_7 = [0, 2, 3, 5, 7, 11, 12, 13, 11, 24]$
	\item \texttt{test\_make\_job\_<attack>}\footnotemark: $t_8 = [0, 2, 3, 5, 6, 7, 11, 12, 14, 15, 16, 18, 24]$
	\item \texttt{test\_set\_job\_fin}: $t_9 = [0, 2, 3, 5, 7, 8, 11, 12, 14, 16, 17, 18, 24]$
	\item \texttt{test\_retry\_job\_<attack>}\footnotemark[\value{footnote}]: $t_{10} = [0, 2, 3, 5, 6, 7, 11, 12, 14, 16, 17, 18, 24]$
	\item \texttt{test\_set\_package\_timeout}: $t_{11} = [0, 2, 3, 5, 7, 8, 11, 12, 14, 16, 18, 19, 20, 24]$
	\item \texttt{test\_set\_package\_exhausted}: $t_{12} = [0, 2, 3, 5, 7, 8, 11, 12, 14, 16, 18, 19, 21, 22, 24]$
	\item \texttt{test\_set\_package\_ready}: $t_{13} = [0, 2, 3, 5, 7, 8, 11, 12, 14, 16, 18, 19, 21, 23, 24]$
\end{itemize}
\footnotetext{<attack> môže byť dict(slovníkový), comb(kombinačný), mask, alebo error, kedy má typ útoky neplatnú hodnotu.}
\begin{center}
	$T_1 = {t_1, t_3, t_4, \ldots t_{13}}$ splňuje NC. 
\end{center}
Bolo implementovaných viac testov ako bolo potrebné na pokrytie NC, no pseudokód nerozlišuje medzi typmi útokov a inými implementačnými podrobnosťami.

\bigskip
\noindent
Podrobnosti k implementácii testov je možné vyčítať zo samotných zdorjových kódov, ako aj z komentárov k zdrojovým kódom.

\section{Implementácia testov pre modul runner}
\label{impl_runner}
Pred začatím testov by mali byť splnené tieto body:
\begin{itemize}
	\item zložka s testami bude obsahovať spustiteľný súbor modulu runner,
	\item v konfiguračnom súbore \texttt{config.py} bude správne meno spustiteĺného súboru modulu runner,
	\item dvojník Hashcat-u \texttt{hashcat\_mock.py} je prekopírovaný / premenovaný tak ako to vyžaduje runner, momentálne \texttt{hashcat64.bin},
	\item premenovaný Hashcat mock musí mať nastavené spustiteľné práva, aby ho bolo možné spustiť aj bez špecifikácie interpretu: \texttt{./hascat64.bin}.
\end{itemize}

\subsection*{Architektúra}
Testovací prípad pripraví súbory~\ref{from_server} v závislosti na úlohe a zavolá runner.
Do súboru \texttt{local.conf} zapíše dodatočné parametre ak je to potrebné:
\begin{itemize}
	\item \texttt{--error}: mock prekopíruje na svoj výstup súbor obsahujúci chybový výstup Hashcatu a skončí s návratovou hodnotou -1,
	\item \texttt{--warning}: na výstupe je platný výstup z Hashcat-u, ale s varovaniami,
	\item \texttt{--found}: slúži na rozlišenie, či heslo bolo nájdené, alebo nie.
\end{itemize}
Runner spúšťa mock Hashcat-u, kontroluje výstup a vytvára výstupný súbor.
Hashcat mock parsuje argumenty~\ref{parsing} a podľa argumentov kopíruje na výstup jeden z predpripravených výstupov Hashcat-u.
Do súboru zapiše aj všetky parametre, ktoré mu poslal runner.

Keď runner skončí je overované s akým návratovým kódom skončil, aké argumenty poslal Hashcat-u~\ref{parsing} a obsah výstupného súboru.
Schéma je znázornená aj na obrázku~\ref{fig:runner_files}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{obrazky/runner_files.pdf}
	\caption{Schéma architektúry testov modulu runner.}
	\label{fig:runner_files}
\end{figure}

\subsection*{Parsovanie}
\label{parsing}
Pre parsovanie argumentov, ktoré runner posiela Hashcat-u som použil modul \texttt{argparse}\footnote{\url{https://docs.python.org/3/library/argparse.html}}, ktorý funguje tak, že je potrebné vytvoriť objekt parser, ktorému môžme neskôr špecifikovať argumenty.
Súbor \texttt{hashcat\_parsers.py} definuje 2 objekty:
\begin{itemize}
	\item \texttt{initial/benchmark parser} -- slúži na zistenie základných informácii, ktoré by mali byť posielané stále, alebo iba pri benchmarku
	\item \texttt{normal parser} -- slúži na parsovanie normálnej úlohy.
\end{itemize}
Súbor ďalej obsahuje aj funkcie na prácu s týmito objektmi.
Prvá je stále volaná funkcia \texttt{initial\_parse()}, ktorá vráti dvojicu: objekt reprezentujúci argumenty a pole nesprarsovaných argumentov.
Podľa typu úlohy, alebo útoku je volaná jedna z nasledujúcich funkcií:
\begin{itemize}
	\item \texttt{parse\_mask\_attack()},
	\item \texttt{parse\_dict\_attack()},
	\item \texttt{parse\_comb\_attack()}.
\end{itemize}
Testovacie prípady by mali pracovať výhradne s týmito funkciami.

\section{Implementácia testov aplikačného rozhrania (API)}
\label{impl_API}
Súbor \texttt{test\_runner.py} je jediný z test súborov, ktorý obsahuje viac tried.
Na testovanie každého koncového bodu(endpoint) API slúži vlastná trieda, tak ako to opisuje návrh~\ref{navrh_API}, tým pádom je možné viac používať \texttt{setUp a tearDown} funkcie.
Koncový bod takisto posiela iné dáta a práve na vytváranie \texttt{json} objektov v rovnakom formáte slúžia funkcie zo súboru \texttt{api\_response\_models.py}.
Testy API často využívajú subset-y~\ref{impl_asim} a snaží sa kombinovať triedy domén. 
Pre väčšiu prehľadnosť je najskôr funkcia testovaná iba s jedným parametrom, tak že je postupne spúšťaná s jedným zástupcom z každej triedy testovaného parametru (ostatné parametre majú východzie hodnoty) a až keď prešli všekty testy pre všetky parametre samostatne, tak je spustený test, ktorý overuje chovanie pri všetkých kombináciach tried parametrov (All Combination Coverage)~\ref{kriteria_pokrytia_domen}.
